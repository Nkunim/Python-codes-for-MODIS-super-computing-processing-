# -*- coding: utf-8 -*-
#!/usr/bin/env python

"""
A python code for processing MODIS data at individual sites (mod09a1).
1 read in ascii file or csv table from MODIS raw csv file which generated by http://eomf.ou.edu/visualization/gmap/ page
2 convert dn value to reflectance data
3 calculate vegetation indices
4 decode the quality flag
5 identify bad quality data and do a gap-filling  for both reflectance data and vegetation indices
"""

import csv
#from Tkinter import *
#from tkFileDialog import askopenfilename

#change the file path to your csv file, using \\ instead of \ in windows system
#filename = "T:\\delong\\python_code_delong\\mod09a1_indices_qc_gapfill_command_line\\sample.csv"
#filename = "C:\\2010\\python code for processing MODIS time series data\\csv_mod09a1_2008_43.135113_70.936508.csv"
#root=Tk()
#filename = askopenfilename(filetypes=[("allfiles","*"),("csvfiles","*.csv")])

### TRY TO GET A FILENAME FROM THE COMMAND LINE:
try:
	filename=sys.argv[1] #first argument, e.g. 'latest.mdf'
	print "first argument was the input filename:",sys.argv[1]
except: #if nothing from command line, ask user for it
	print "filename was not entered from command line, so"
	filename=raw_input("enter filename=>")


skiplines = 0
delimiter =","
outfile = filename[:-4]+"_output.csv"
print outfile


try:
        inf=open(filename,'r')
        fileopen=True
except:
        print "trouble opening",filename,",try another file ..."

csvWriter = csv.writer(open(outfile,'wb'))

all=inf.readlines()
header=""
for n in range(skiplines):
        header+=all.pop(0)

#print header

columntitles=all.pop(0) #take and then remove (pop) first line 
#print columntitles
columntitles = columntitles.rstrip() 
ct = columntitles.split(delimiter)
ct.extend(['red','nir1','blue','green','nir2','swir1','swir2'])
ct.append("NDVI")
ct.append("EVI")
ct.append("LSWI")
ct.append("NDSI")
ct.append("NDWI1200")
ct.append("sur_refl_state_500m")
qc_list = ['MOD35 cloud','cloud shadow','land/water flag','aerosol quantity','cirrus detected','internal cloud algorithm flag','internal fire algorithm flag','MOD35 snow/ice flag','Pixel is adjacent to cloud','BRDF correction performed','internal snow algorithm flag']
ct.extend(qc_list)
ct.append("Bad observation")
ct.append("Gap_fill_applied")
ct.extend(["GF_NDVI","GF_EVI","GF_LSWI","GF_NDSI","GF_NDWI1200"])
print ct

csvWriter.writerow(ct)

def ndvi(nir,vis):
        ndvi = (float(nir)-float(vis))/(float(nir)+float(vis))
        return ndvi

def evi(nir,vis,blue):
        nir = float(nir)
        vis = float(vis)
        blue = float(blue)
        evi = 2.5*(nir-vis)/(nir+6*vis-7.5*blue+1)
        return evi

def lswi(nir,swir):
        nir = float(nir)
        swir = float(swir)
        lswi = (nir-swir)/(nir+swir)
        return lswi

#For Terra data, the algorithm uses MODIS Bands 4 (0.55 µm) and 6 (1.6 µm)
#to calculate the NDSI.
#MODIS Band 6 detectors failed on Aqua shortly after launch,
#so Band 7 (2.1 µm) is used to calculate the NDSI for Aqua
def ndsi(band4,band6):
        band4 = float(band4)
        band6 = float(band6)
        ndsi = (band4-band6)/(band4+band6)
        return ndsi

def ndwi1200(band860,band1200):
        band860 = float(band860)
        band1200 = float(band1200)
        ndwi1200 = (band860-band1200)/(band860+band1200)
        return ndwi1200


def denary2binary(i):
        if i<0:
                u16 = i%2**16
                b16 = bin(u16)
        if i == 0:
                b16 = '0b0000000000000000'
        if i >0:
                b16 = bin(i)
        b16 = b16[2:]
        while(len(b16)<16):
                b16 ='0'+b16
        return b16

def mod35_cloud(ii):
        cloud={  '00':'clear',
                '01':'cloudy',
                '10':'mixed',
                '11':'not set, assumed clear'
                }
        return cloud[ii]

def cloud_shadow(i):
        cloud_s = {'1':'yes',
                        '0':'no'
                        }
        return cloud_s[i]


def land_water(iii):
        lw = {'000':'shallow ocean',
              '001':'land',
              '010':'ocean coastlines and lake shorelines',
              '011':'shallow inland water',
              '100':'ephemeral water',
              '101':'deep inland water',
              '110':'continental/moderate ocean',
              '111':'deep ocean'
              }
        return lw[iii]

def aerosol_quality(ii):
        aq = {'00':'climatology',
              '01':'low',
              '10':'average',
              '11':'high'
              }
        return aq[ii]

def cirrus(ii):
        cs = {'00':'none',
              '01':'small',
              '10':'average',
              '11':'high'
              }
        return cs[ii]

def cloud_algorithm(i):
        ca = {'1':'cloud',
              '0':'no cloud'
              }
        return ca[i]

def fire_algorithm(i):
        fa = {'1':'fire',
              '0':'no fire'
              }
        return fa[i]

def snow_ice(i):
        si = {'1':'yes',
              '0':'no'
              }
        return si[i]

def pixel_adjacent_cloud(i):
        pac = {'1':'yes',
               '0':'no'
               }
        return pac[i]

def BRDF_correction(i):
        BRDF = {'1':'yes',
                '0':'no'
                }
        return BRDF[i]

def snow_algorithm(i):
        sa = {'1':'yes',
              '0':'no'
              }
        return sa[i]

def decode(qc2):
        cloud = mod35_cloud(qc2[14:16])
        cloud_s = cloud_shadow(qc2[13])
        lw = land_water(qc2[10:13])
        aq = aerosol_quality(qc2[8:10])
        cs = cirrus(qc2[6:8])
        ca = cloud_algorithm(qc2[5])
        fa = fire_algorithm(qc2[4])
        si = snow_ice(qc2[3])
        pac = pixel_adjacent_cloud(qc2[2])
        BRDF = BRDF_correction(qc2[1])
        sa = snow_algorithm(qc2[0])

        code_list = [cloud,cloud_s,lw,aq,cs,ca,fa,si,pac,BRDF,sa]
        return code_list

def gap_fill(t_minus_1,t_plus_1):
        result = []
        for index, item in enumerate(t_minus_1[22:27]):#average index not reflectance
                t = (item+t_plus_1[index+22])/2
                result.append(t)
        return result

def process_line(line):
        line = line.rstrip()    # Remove trailing whitespace.
        v=line.split(delimiter) #split line at delimiter
        nir = float(v[2])*0.0001 #band2
        vis = float(v[1])*0.0001 #band1
        blue = float(v[3])*0.0001 #band3
        swir = float(v[6])*0.0001 #band6
        band4 = float(v[4])*0.0001 #band4
        band6 = float(v[6])*0.0001 #band6
        band860 = float(v[2])*0.0001 #band860
        band1200 = float(v[5])*0.0001 #band1200

        reflectance = [float(b)*0.0001 for b in v[1:8]] 

        qc2 = denary2binary(int(v[-3]))

        decode_list = decode(qc2)
        
        #print v[1],v[2]
        #print nir,vis
        v.extend(reflectance)
        v_ndvi = ndvi(nir,vis)
        v_evi = evi(nir,vis,blue)
        v_lswi = lswi(nir,swir)
        v_ndsi = ndsi(band4,band6)
        v_ndwi1200 = ndwi1200(band860,band1200)        
        v.append(v_ndvi)
        v.append(v_evi)
        v.append(v_lswi)
        v.append(v_ndsi)
        v.append(v_ndwi1200)
        v.append(qc2)
        v.extend(decode_list)
        
        #print v
        return v


          
                
lines = []
        
lable = ''
for line in all:
        v_t = process_line(line)
        print v_t
        lines.append(v_t)
        #lable = lable + '\n' + str(v_t) +'\n'
        


i=0
for line in lines:
        #print line[20]
        if line[27][-3:]=='000':#
                line.append('No')
                #print line[-1]
        else:
                line.append('Yes')
                #print line[-1]
                i=i+1
        print line
filled=0
j=1
for line in lines:
        #print j
        print line
        #print lines[j-1]
        #print lines[j-2][39]
        #print lines[j-1][39]
        if line[39]=='Yes':#
                if j==1:
                        line.append('NA')# first observation cannot fill
                        #print line[-1]
                        line.extend(line[22:27])
                        
                elif j==(len(lines)):
                        line.append('NA')#last observation'
                        #print line[-1]
                        line.extend(line[22:27])
                        
                else:
                        if lines[j-2][39]=='No' and lines[j][39]=='No':#
                                line.append('Yes')
                                t_average_index = gap_fill(lines[j-2],lines[j])
                                line.extend(t_average_index)
                                filled = filled +1
                                #print line[-1]
                        elif lines[j-2][39]=='No' and lines[j][39]=='Yes':#
                                line.append('NA')#t+1 also defective
                                #print line[-1]
                                line.extend(line[22:27])
                                
                        elif lines[j-2][39]=='Yes' and lines[j][39]=='No':#
                                line.append('NA')#'t-1 also defective'
                                #print line[-1]
                                line.extend(line[22:27])
                                
                        elif lines[j-2][39]=='Yes' and lines[j][39]=='Yes':
                                line.append('NA')#Should but cannot,both adjucent time defective
                                #print line[-1]
                                line.extend(line[22:27])
                                

        elif line[39]=='No':
                line.append('No')
                #print line[-1]
                line.extend(line[22:27])#
                                    
        j=j+1
                        
                
#print "\n", len(lines)
csvWriter.writerows(lines)
#print lines

print '\n'
print '%d records processed. \n %d bad observations which are  either not clear cloud or has cloud shadow.\n %d bad obervations have been filled by average t-1,t+1 records. \n'  %(len(lines),i,filled)
print 'Output file is %s' %outfile
print "\n Finished.\n"
